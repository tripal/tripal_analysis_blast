<?php
//$Id:

/*******************************************************************************
 * Implementation of hook_install().
 */
function tripal_analysis_blast_install() {
   // create the module's data directory
   tripal_create_moddir('tripal_analysis_blast');

   // We need to register to tripal_analysis module so it can provide a control
   // for our blast result. Basically the registration is done by inserting
   // modulename into the drupal {tripal_analysis} table AND inserting required
   // information to the chado Analysis table. Also in tripal_analysis_blast.module,
   // we need to define HOOK_get_settings() for the module to work properly.   
   // Register the analysis type
   tripal_analysis_register_child('tripal_analysis_blast');
   
   // Add cvterms
   tripal_analysis_blast_add_cvterms();
   
   // Create a tripal_analysis_blast table to store parsers
   drupal_install_schema('tripal_analysis_blast');
   
   // drop the 'blast_hit_data' table created from the drupal_install_schema()
   // call above, we want this table in Chado, not in Drupal
   $sql = "DROP table blast_hit_data";
   db_query($sql);
   
   // add Chado tables
   tripal_analysis_blast_add_chado_tables();
   
   // Create default parser for swissprot, DB:genbank, and go-seqdb
   $sql_db = "SELECT db_id, name FROM {db} WHERE name like '%s'";
   $sql_parser = "INSERT INTO {tripal_analysis_blast} ".
                 "  (db_id, displayname, regex_hit_id, regex_hit_def, ".
                 "   regex_hit_accession, genbank_style, regex_hit_organism) ".
                 "VALUES (%d, '%s', '%s', '%s', '%s', %d, '%s')";
   
   // Add swissprot parser
   $previous_db = tripal_db_set_active ('chado');
   $results = db_query($sql_db, "%swissprot%");
   tripal_db_set_active($previous_db);
   while ($db = db_fetch_object($results)) {
      db_query($sql_parser, $db->db_id, 'ExPASy Swissprot', 
         '^sp\|.*?\|(.*?)\s.*?$', '^sp\|.*?\|.*?\s(.*)$', 'sp\|(.*?)\|.*?\s.*?$', 
         0,'^.*?OS=(.*?)\s\w\w=.*$');
   }
   
   // Add trembl parser
   $previous_db = tripal_db_set_active ('chado');
   $results = db_query($sql_db, "%trembl%");
   tripal_db_set_active($previous_db);
   while ($db = db_fetch_object($results)) {
      db_query($sql_parser, $db->db_id, 'ExPASy TrEMBL', '^.*?\|(.*?)\s.*?$', 
         '^.*?\|.*?\s(.*)$', '^(.*?)\|.*?\s.*?$', 0,'^.*?OS=(.*?)\s\w\w=.*$');
   }
   
   // Add NCBI genbank parser
   $previous_db = tripal_db_set_active ('chado');
   $results = db_query($sql_db, "%genbank%");
   tripal_db_set_active($previous_db);
   while ($db = db_fetch_object($results)) {
      db_query($sql_parser, $db->db_id, 'Genbank', '', '', '', 1, '');
   }
}

/*******************************************************************************
 * Implementation of hook_uninstall().
 */
function tripal_analysis_blast_uninstall() {
   
   // Delete all information associate with the module
   // Drupal complains when the user tries to uninstall tripal_analysis 
   // and tripal_analysis_blast at the same time. This is because Drupal drops
   // the {tripal_analysis} table before we can delete anything from it. Thus,
   // we perform a db_table_exists() check before the deletion
   
   //Delete the settings from {tripal_analysis} table
   tripal_analysis_unregister_child('tripal_analysis_blast');

   // Delete module's variables from variables table.
   db_query("DELETE FROM {variable} WHERE name='%s'",
            'tripal_analysis_blast_setting');
            
   // Delete a tripal_analysis_blast table
   drupal_uninstall_schema('tripal_analysis_blast');
}
/*******************************************************************************
* Function for adding new tables to Chado specific for this module
*/
function tripal_analysis_blast_add_chado_tables(){

   // the schema for our custom Chado tables are in the .module file
   // so that they integrate properly with everything else Chado.
   $ret = array();
   $schema = tripal_analysis_blast_chado_blast_hit_data_schema();
   tripal_create_chado_table ($ret,'blast_hit_data',$schema);
}
/**
 *  The blast analysis module creates it's own custom table for storing
 *  blast results in a format more condusive for fine-grained searching.
 *  Therefore, we must define the hook_schema function, as recoginzed by
 *  the Tripal core API, for specifying the details for this table.
 *  This is the implementation of hook_chado_table_schema() (where 'table'
 *  is the name of the table in Chado and 'hook' is the name of the module).
 *  
 *  @return
 *     An associative array in the Drapal Schema API format.
 */
function tripal_analysis_blast_chado_blast_hit_data_schema(){
   $description = array(
      'table' => 'blast_hit_data',
      'fields' => array(
         'analysisfeature_id'  => array('type' => 'int', 'not null' => TRUE),
         'analysis_id'         => array('type' => 'int', 'not null' => TRUE),
         'feature_id'          => array('type' => 'int', 'not null' => TRUE),
         'db_id'               => array('type' => 'int', 'not null' => TRUE),
         'hit_num'             => array('type' => 'int', 'not null' => TRUE),
         'hit_name'            => array('type' => 'varchar', 'length' => 1025, 'not null' => FALSE),
         'hit_url'             => array('type' => 'text',  'not null' => FALSE),
         'hit_description'     => array('type' => 'text',  'not null' => FALSE),
         'hit_organism'        => array('type' => 'varchar', 'length' => 1025, 'not null' => FALSE),
         'hit_accession'       => array('type' => 'varchar', 'length' => '255', 'not null' => FALSE),
         'hit_best_eval'       => array('type' => 'float', 'size' => 'big', 'not null' => FALSE),
         'hit_best_score'      => array('type' => 'float', 'size' => 'big', 'not null' => FALSE),
         'hit_pid'             => array('type' => 'float', 'size' => 'big', 'not null' => FALSE),
      ),
      'indexes' => array(
         'analysisfeature_id' => array('analysisfeature_id')
      ),
   );
   $description['foreign keys']['db'] = array(
     'table' => 'db',
     'columns' => array(
       'db_id' => 'db_id',
     ),
   );
   $description['foreign keys']['analysisfeature'] = array(
     'table' => 'analysisfeature',
     'columns' => array(
       'analysisfeature_id' => 'analysisfeature_id',
     ),
   );
   return $description;
}
/*******************************************************************************
* Implementation of hook_schema(). This table stores the parsers for blast xml
* xml results.
*/
function tripal_analysis_blast_schema() {
   $schema = array();
   $schema['tripal_analysis_blast'] = array(
      'fields' => array(
         'db_id'               => array('type' => 'int','unsigned' => TRUE,'not null' => TRUE,'default' => 0),
         'displayname'         => array('type' => 'varchar','length' => 255,'not null' => TRUE,),
         'regex_hit_id'        => array('type' => 'varchar','length' => 255,),
         'regex_hit_def'       => array('type' => 'varchar','length' => 255,),
         'regex_hit_accession' => array('type' => 'varchar','length' => 255,),
         'regex_hit_organism'  => array('type' => 'varchar','length' => 255,),               
         'hit_organism'        => array('type' => 'varchar','length' => 255,),               
         'genbank_style'       => array('type' => 'int','unsigned' => TRUE,'default' => 0),
      ),
      'indexes' => array(
         'db_id' => array('db_id')
      ),
      'primary key' => array('db_id'),
  );
  // The blast_hit_data table is defined in the module code. This is because
  // we also need to define the schema for the Tripal core API.  We have to also
  // include it here so that Drupal understands the table structure.  When the 
  // module gets installed it will cause a table 'blast_hit_data' to be installed
  // in the Drupal database because it is listed here in the $schema array.  
  // We don't want this, as this table needs to be in Chado, so in the
  // hook_install() function we will drop the table from the Drupal database.
  $schema['blast_hit_data']  = tripal_analysis_blast_chado_blast_hit_data_schema();
   
  return $schema;
}

/*******************************************************************************
 * Implementation of hook_requirements(). Make sure 'Tripal Core' and 'Tripal
 * Analysis' are enabled before installation
 */
function tripal_analysis_blast_requirements($phase) {
   $requirements = array();
   if ($phase == 'install') {
      if (!function_exists('tripal_create_moddir') || !function_exists('tripal_analysis_register_child')) {
         $requirements ['tripal_analysis_blast'] = array(
            'title' => "tripal_analysis_blast",
            'value' => "error. Some required modules are just being installed. Please try again.",
            'severity' => REQUIREMENT_ERROR,
         );
      }
   }
   return $requirements;
}

/*******************************************************************************
 * Provide update script for adding new cvterms
 */
function tripal_analysis_blast_update_6000(){

   // we have some new cvterms to add
   tripal_analysis_blast_add_cvterms();

   $ret = array(
      '#finished' => 1,
   );
   
   return $ret;
}
/*******************************************************************************
 * Provide update for module version v6.x-0.4-0.1
 */
function tripal_analysis_blast_update_6001(){

   // we have some new cvterms to add
   tripal_analysis_blast_add_cvterms();
   
   // add new blast hit data table
   $schema = tripal_analysis_blast_schema();
   
   // add new chado tables
   tripal_analysis_blast_add_chado_tables();
   
   // alter the tripal_blast_analysis table we need to add two new columns
   // and extend the sizes of the others.
   db_add_field($ret, 'tripal_analysis_blast', 'regex_hit_organism',array('type' => 'varchar','length' => 255));   
   db_add_field($ret, 'tripal_analysis_blast', 'hit_organism',array('type' => 'varchar','length' => 255));  
   db_change_field($ret,'tripal_analysis_blast','regex_hit_id','regex_hit_id',array('type' => 'varchar','length' => 255,));
   db_change_field($ret,'tripal_analysis_blast','regex_hit_def','regex_hit_def',array('type' => 'varchar','length' => 255,));
   db_change_field($ret,'tripal_analysis_blast','regex_hit_accession','regex_hit_accession',array('type' => 'varchar','length' => 255,));
   db_change_field($ret,'tripal_analysis_blast','genbank_style','genbank_style',array('type' => 'int','unsigned' => TRUE,'default' => 0));
   db_change_field($ret,'tripal_analysis_blast','displayname','displayname',array('type' => 'varchar','length' => 255,'not null' => TRUE,));
   $ret = array(
      '#finished' => 1,
   );
   
   return $ret;
}

/*******************************************************************************
 * Function for adding cvterms
 */
function tripal_analysis_blast_add_cvterms () {
	
   // Add the cvterms for the anlysisprop table
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_settings', 'def' => 'Settings of a blast analysis, '.
      'including db_id, output file, and run parameters separated by a bar |'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_blastdb','def' => 'The database used for blasting'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_blastfile','def' => 'The input file or directory that contains the XML blast output'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_blastparameters','def' => 'The parameters used when performing blast.'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_no_parsed','def' => 'Indicates if the input file should be parsed to map results to features'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_query_re','def' => 'The regular expression for finding the feature name in the query definition line of the blast results'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_query_type','def' => 'The feature type (e.g. mRNA, polypeptide) of the query input file. This type is used to identify the query feature when multiple features have the same name'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_query_uniquename','def' => 'Indicates if the matched name in the query definition line of the blast results is feature uniquename'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_blastfile_ext','def' => 'Indicates the extension of the blast files. This is required if the blastfile setting is a directory.'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_is_concat','def' => 'Indicates if the blast results XML file is a series of concatenated XML results.  Such is the case, for example, if Blast2GO was used to perform the analysis.'),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_search_keywords','def' => 'Indicates the fields that should be stored in the analysisfeatureprop table for the blast results.'),'tripal',0,1,'tripal');
   
   // add cvterms for the blast search keywords
	tripal_cv_add_cvterm(array('name' => 'blast_match_name','def' => 'The blast match name'),'tripal',0,1,'tripal');
	tripal_cv_add_cvterm(array('name' => 'blast_match_description','def' => 'The match description'),'tripal',0,1,'tripal');
	tripal_cv_add_cvterm(array('name' => 'blast_match_organism','def' => 'The organism the blast match belongs to'),'tripal',0,1,'tripal');
 	tripal_cv_add_cvterm(array('name' => 'blast_match_accession','def' => 'The accession of the blast match'),'tripal',0,1,'tripal');
	tripal_cv_add_cvterm(array('name' => 'blast_database','def' => 'The name of the database blasted against'),'tripal',0,1,'tripal');
	tripal_cv_add_cvterm(array('name' => 'blast_evalue','def' => 'The blast match e-valuue score (best e-value if multiple HSPs'),'tripal',0,1,'tripal');
	tripal_cv_add_cvterm(array('name' => 'blast_score','def' => 'The blast hit match bit score'),'tripal',0,1,'tripal');
	tripal_cv_add_cvterm(array('name' => 'blast_pid','def' => 'The blast hit match percent identity'),'tripal',0,1,'tripal');
   
   // Add cvterm 'analysis_blast_output_iteration_hits' for inserting into featureprop table
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_output_iteration_hits', 'def' => 'Hits of a blast '.
      'output iteration. Each iteration corresponds to a chado feature, and is '.
      'the content between <iteration> and </iteration> tags in the blast xml '.
      'output file. This cvterm represents all hits in the iteration'),'tripal',0,1,'tripal');
   
   // Add cvterms for the best hits report
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_besthit_query', 'def' => 'query name of the best hit 
      associated with a feature and a blast analysis '),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_besthit_match', 'def' => 'match name of the best hit 
      associated with a feature and a blast analysis '),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_besthit_description', 'def' => 'description of the best hit 
      associated with a feature and a blast analysis '),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_besthit_evalue', 'def' => 'evalue of the best hit 
      associated with a feature and a blast analysis '),'tripal',0,1,'tripal');
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_besthit_identity','def' =>  'identity (%) of the best hit 
      associated with a feature and a blast analysis '),'tripal',0,1,'tripal'); 
   tripal_cv_add_cvterm(array('name' => 'analysis_blast_besthit_length','def' =>  'length of the best hit 
      associated with a feature and a blast analysis '),'tripal',0,1,'tripal');
   
}
